{"name":"Hmvcbundle","tagline":"Symfony2 Bundle providing a fast Hierarchical Model View Controller (HMVC) solution utilizing Symfony's dispatch flow to call internal services in the same way you would call it externally. It integrates fully with RESTful controllers from FOSRestBundle, KnpRadBundle and native Symfony.","body":"Morket's HMVCBundle (ALPHA, in development)\r\n====================================\r\n[![Build Status](https://travis-ci.org/Morket/HMVCBundle.png)](http://travis-ci.org/Morket/HMVCBundle)\r\n\r\nWhy are external application calls using a RESTful interface while internal application calls consist of many custom Model methods? Why are internal services different from external services? They shouldn't. The current web is a cloud with services, now you're application can be as well.\r\n\r\nThe HMVCBundle is a Symfony2 Bundle providing a fast Hierarchical Model View Controller (HMVC) solution utilizing Symfony's dispatch flow to call internal services in the same way you would call it externally. It integrates fully with RESTful controllers from FOSRestBundle, KnpRadBundle and native Symfony.\r\n\r\nConcept\r\n-----------\r\nA lot has been written about the Model View Controller pattern and the fact that all your business logic should be put into the Model layer. Conceptually this is totally true, but practically it can be a pain in the ass. A lot of development time goes to mapping Controller actions to Model objects and methods. A lot of time is spent on deciding where to put code and how to structure it well. Where do I put my Forms? Shouldn't I validate from the Model layer as well? If I use annotations to validate my GET and POST values, shouldn't I validate the entity again in the Model layer? Why does my Controller have create/read/update/delete methods mapping to create/read/update/delete methods from my Model layer?\r\n\r\nOur statement is that Model View Controller is not that suitable for modern web development and it's outdated. Problem #1 is the fact that there are no real events fired from the View layer, which makes every request just a single application flow. Problem #2 is that we prefer convention over configuration these days, making our Controller layer extremely predictable and repetitive.\r\n\r\nWe aim for a Presentation Abstraction Control (PAC) approach of web development. Look at a Controller as an entrance to one service within your application. See it as a Control element handling flow, rather than application logic. Your Control layer can call a Form or Doctrine Repository directly, it can perform validation and it can have some business logic. When it gets complex, naturally you will write Abstraction classes to solve this complexity. PAC encourages this. Your Presentation layer will be used for template rendering or serialization (to JSON/XML for example). A template within the Presentation layer could or could not call another Control element to present some extra stuff, like a logged in user on top of a page.\r\n\r\nEach service is a MVC/PAC island. You could have a User service and a Product service, which always call each other via the Control element of the service. And because the Control layer is implemented as Symfony2 Controllers, they are also callable from the outside. Using RESTful Bundles like FOSRestBundle or KnpRadBundle, you automatically create an internal and external RESTful API to all your services.\r\n\r\nHow HMVCBundle works\r\n----------------------------------\r\nThe HMVCBundle uses Symfony's normal Request handling flow to make internal calls. It returns the returned data from the Controller\r\nand makes it available elsewhere. It's quite simular to Symfony's forward method, but without the whole HTML/JSON/XML rendering process.\r\nCurrently using the HMVC trait (PHP 5.4+) adds one method to controllers:\r\n``` php\r\n$this->call($route, $attributes = array(), $data = array(), $query = array(), $rawResponse = false)\r\n```\r\nParam            | Explanation\r\n-----------------|------------------------------------------------------------------------------------------------\r\n**$route**       | is the Symfony route\r\n**$attributes**  | are request/route attributes, which are defined as parameters in your Controller action methods\r\n**$data**        | is POST data\r\n**$query**       | is an array of query params (\"GET params\")\r\n**$rawResponse** | will force HMVC to return a Symfony2 Response object instead of returning the data directly\r\n\r\nYou can still use your own Controllers, Event Listeners, Views, Templates and Serializers.\r\nThe HMVCBundle won't affect normal behavior, it will only add functionality for internal requests.\r\n\r\n**PHP 5.3: morket_hmvc.agent**\r\n\r\nYou could just call the service **morket_hmvc.agent**, which has the same call() method as documented above.\r\nIt works exactly the same as the trait described in this README. Good examples will be added shortly.\r\n\r\n**kernel.view event**\r\n\r\nThe Bundle WILL probably and SHOULD block your kernel.view (onKernelView()) events when making an internal call. This is necessary to make sure no HTML/JSON/XML is rendered for internal (HMVC) requests. The kernel.view event is defined with priority 128, so it will block FOSRestBundle's and KnpRadBundle's kernel.view events, but you can still out-prioritize it. This is native Symfony behavior, Symfony will always allow only one kernel.view per (sub)request, because output can only be rendered once.\r\n(Note: kernel.view is fired when a Controller returns something else than a Response object, like an array of data or a View object)\r\n\r\n**Exceptions**\r\n\r\nWhen doing an internal HMVC call, any thrown Exceptions will be thrown through, meaning you can catch them in the Controller where you make the call. See examples below.\r\n\r\nHow to use it\r\n------------------\r\nJust use the trait Morket\\Bundle\\HMVCBundle\\Controller\\HMVC in each Controller you want to make calls from. That's all. HMVC won't affect existing software in any way. You can partially use HMVC, or include the Bundle and not use it at all. It won't break stuff.\r\n\r\n**Simple example without dependencies**\r\n``` php\r\n<?php\r\nnamespace Acme\\Controller;\r\n\r\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\r\nuse Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\r\n\r\nuse Morket\\Bundle\\HMVCBundle\\Controller\\HMVC;\r\n\r\nclass ProductsController extends Controller\r\n{\r\n    use HMVC;\r\n\r\n    public function getProductsAction()\r\n    {\r\n        try {\r\n            $user = $this->call('get_user', ['id' => $this->getRequest()->get('user_id')]);\r\n            // do something\r\n        } catch (NotFoundHttpException $e) {\r\n            // user not found\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**Really practical example using the provided RadRestController, depending on both FOSRestBundle and KnpRadBundle**\r\n``` php\r\n<?php\r\n\r\nnamespace Acme\\Controller;\r\n\r\nuse Acme\\Entity\\User;\r\nuse FOS\\RestBundle\\Controller\\Annotations\\View;\r\nuse FOS\\RestBundle\\Controller\\Annotations\\RequestParam;\r\nuse FOS\\RestBundle\\Controller\\Annotations\\QueryParam;\r\nuse FOS\\RestBundle\\Request\\ParamFetcher;\r\nuse Morket\\Bundle\\HMVCBundle\\Controller\\RadRestController;\r\nuse Symfony\\Component\\HttpKernel\\Exception\\HttpException;\r\n\r\nclass UsersController extends RadRestController\r\n{\r\n    /**\r\n     * @View\r\n     */\r\n    public function getUserAction($id)\r\n    {\r\n        return array('user' => $this->findOr404('App:User', ['id' => $id]));\r\n    }\r\n\r\n    /**\r\n     * @QueryParam(name=\"filter\", requirements=\"[a-z]+\", strict=true)\r\n     * @View\r\n     */\r\n    public function getUsersAction(ParamFetcher $paramFetcher)\r\n    {\r\n        return ['users' => $this->getRepository('App:User')\r\n                                ->search($paramFetcher->get('filter'))];\r\n    }\r\n\r\n    /**\r\n     * @RequestParam(name=\"username\", requirements=\"[a-z0-9]+\")\r\n     * @RequestParam(name=\"something\", requirements=\"[a-z]+\")\r\n     */\r\n    public function postUsersAction($username, $something)\r\n    {\r\n        // We're illustrating the use of @RequestParam here, not best practices in saving a user entity\r\n\r\n        $user = new User;\r\n        $user->setUsername($username);\r\n        $user->setSomething($something);\r\n        $this->persist($user, true);\r\n\r\n        return $this->routeRedirectView('get_user', ['id' => $user->getId()], 201);\r\n    }\r\n\r\n    /**\r\n     * @View\r\n     */\r\n    public function putUserAction($id)\r\n    {\r\n        $user = new User;\r\n        $user->setUsername($this->getRequest()->get('username'));\r\n        $user->setSomething($this->getRequest()->get('something'));\r\n        $this->persist($user, true);\r\n\r\n        return $this->routeRedirectView('get_user', ['id' => $user->getId()], 200);\r\n    }\r\n\r\n    /**\r\n     * @View\r\n     */\r\n    public function deleteUserAction($id)\r\n    {\r\n        throw new HttpException(500);\r\n    }\r\n}\r\n```\r\n**Somewhere else in your application:**\r\n``` php\r\n<?php\r\nnamespace Acme\\Controller;\r\n\r\nuse Morket\\Bundle\\HMVCBundle\\Controller\\HMVC;\r\nclass InsaneController\r\n{\r\n    use HMVC;\r\n\r\n    public function insaneAction()\r\n    {\r\n        $user = $this->call('get_user', ['id' => 1]); // get a user\r\n        $users = $this->call('get_users', [], [], ['filter' => 'mor']); // get users by filter\r\n\r\n        $this->call('post_users', ['username' => 'morket', 'something' => 'abc']); // add a user\r\n        $this->call('put_user', ['id' => 1], ['username' => 'morket', 'something' => 'cba']); // update user\r\n        $this->call('delete_user', ['id' => 1]); // delete user\r\n    }\r\n}\r\n\r\n```\r\n\r\nAs you can see, all cool stuff from FOSRestBundle and KnpRadBundle is usable, even the annotation like param specifications.\r\nIf you look at the UsersController above, the application will be internally and externally callable like this:\r\n\r\nInternal call  | External call\r\n------------------------------------------------------------------------------------- | ----------------------------------------------\r\n$this->call('get_user', ['id' => 1]);                                                 | GET /users/1\r\n$this->call('get_users', [], [], ['filter' => 'mor']);                                | GET /users?filter=mor\r\n$this->call('post_users', ['username' => 'morket', 'something' => 'abc']);            | POST /users with username=morket&something=abc\r\n$this->call('put_user', ['id' => 1], ['username' => 'morket', 'something' => 'cba']); | PUT /users/1 with username=morket&something=cba\r\n$this->call('delete_user', ['id' => 1]);                                              | DELETE /users/1\r\n\r\nDo you spot the difference between post_users and put_user looking at the way of providing the data in the internal PHP call?\r\nWhen using methods parameters as in postUsersAction($username, $something), you should consider these request attributes instead of POST data.\r\nIf you are using a normal approach, calling either $request->get('something') or $paramFetcher->get('something'), you should\r\nconsider the data POST data.\r\n\r\nAvoiding Service Locator + usage in PHP 5.3\r\n--------------------------------------------\r\nThe HMVC trait uses $this->get() from the Controller, which is a Service Locator. You might consider the Service Locator\r\nan anti-pattern. In that case you want to inject the HMVC agent into the Controller or instantiate it yourself. The default\r\nmorket_hmvc.agent service is defined within the container's request scope, meaning it will be created again for each new\r\nrequest instance. Since the Request parameter is optional in the Agent class, you can create your own service to do\r\nwhatever you like.\r\n\r\nThe following example shows the direct usage of the morket_hmvc.agent service, as a replacement for the PHP 5.4 trait.\r\n``` php\r\n<?php\r\nnamespace Acme\\Controller;\r\n\r\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\r\nuse Symfony\\Component\\HttpKernel\\Exception\\NotFoundHttpException;\r\n\r\nclass ProductsController extends Controller\r\n{\r\n    public function getProductsAction()\r\n    {\r\n        try {\r\n            $user = $this->get('morket_hmvc.agent')\r\n                         ->call('get_user', ['id' => $this->getRequest()->get('user_id')]);\r\n            // do something\r\n        } catch (NotFoundHttpException $e) {\r\n            // user not found\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nMagical convertions\r\n-------------------\r\nThe HMVCBundle provides a custom Response object extending Symfony's normal HTTP Response object.\r\nWhen using the call method, HMVCBundle will automatically get the data from the Response object and return only\r\nthe data directly to you. If the Controller response is an array or FOSRestBundle View with only one element of data, it will\r\nreturn only that element. You can see that in action in the examples above.\r\n\r\n\r\nThe HMVC Response object is NOT used when returning a Response object from the controller. It will only be used when\r\nreturning an array or View object from the Controller. So if you manually return Response objects everywhere (which is also done\r\nwhen returning $this->render()), the HMVC component won't be useful, because you'll be getting HTML/JSON/XML in your code.\r\n\r\nRedirects\r\n---------\r\nLooking at the HTTP specification, there are a lot of occasions where you would want to return a Location HTTP header.\r\nFor example, after a POST you would want to return a 201 Created with the new resource in the Location header.\r\nIn Symfony, we've got the RedirectResponse and in FOSRestBundle there's a RedirectView and RouteRedirectView.\r\n\r\nCurrently HMVCBundle only properly supports FOSRestBundle's RouteRedirectView, which can contain data. Usage is shown in the\r\nexample above. In the near future we will add support for Symfony's native redirects. We will have to map the returned URL's\r\nback to routes and filter out the data. For example, when redirected to /users/1337, we would want to return ['id' => 1337].\r\n\r\nFeel free to contribute if you want to write this part. We use PHPSpec2 to describe behavior.\r\n\r\nTodo's\r\n----------------\r\n1. Testing\r\n2. PHP 5.3 support\r\n3. Convert redirects to data\r\n4. More/better examples in README\r\n5. Automatic caching mechanism\r\n6. Contribute to FOSRestBundle/KnpRadBundle to be able to use both Controllers without copying code\r\n\r\nNeed help or want to contribute?\r\n--------------------------------\r\nFeel completely free to use the Issues on Github for any questions or comments on HMVCBundle or best practices\r\nwhen combining several bundles. Also feel free to send me a mail on <erik@morket.com>.\r\n\r\nMIT License\r\n-------------------------------------------------------------------------------\r\nCopyright (c) 2013 Morket <http://github.com/morket>\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is furnished\r\nto do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}